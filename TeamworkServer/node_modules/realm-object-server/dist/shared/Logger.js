"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const fs = require("fs");
const winston = require("winston");
const events = require("events");
const path = require("path");
var SyncLogLevel;
(function (SyncLogLevel) {
    SyncLogLevel[SyncLogLevel["all"] = 0] = "all";
    SyncLogLevel[SyncLogLevel["trace"] = 1] = "trace";
    SyncLogLevel[SyncLogLevel["debug"] = 2] = "debug";
    SyncLogLevel[SyncLogLevel["detail"] = 3] = "detail";
    SyncLogLevel[SyncLogLevel["info"] = 4] = "info";
    SyncLogLevel[SyncLogLevel["warn"] = 5] = "warn";
    SyncLogLevel[SyncLogLevel["error"] = 6] = "error";
    SyncLogLevel[SyncLogLevel["fatal"] = 7] = "fatal";
    SyncLogLevel[SyncLogLevel["off"] = 8] = "off";
})(SyncLogLevel = exports.SyncLogLevel || (exports.SyncLogLevel = {}));
const levelNames = Object.keys(SyncLogLevel).filter(key => isNaN(Number(key)));
exports.levels = levelNames.reduce(function (acc, cur, i) { acc[cur] = 8 - SyncLogLevel[cur]; return acc; }, {});
const colors = {
    all: "blue",
    trace: "blue",
    debug: "blue",
    detail: "blue",
    info: "green",
    warn: "magenta",
    error: "red",
    fatal: "red",
    off: "yellow",
};
class Logger extends events.EventEmitter {
    withContext(ctx) {
        return new Contextual(this, ctx);
    }
    close() {
        this.removeAllListeners();
    }
    trace(msg, ctx) {
        this.log('trace', msg, ctx);
    }
    debug(msg, ctx) {
        this.log('debug', msg, ctx);
    }
    detail(msg, ctx) {
        this.log('detail', msg, ctx);
    }
    info(msg, ctx) {
        this.log('info', msg, ctx);
    }
    warn(msg, ctx) {
        this.log('warn', msg, ctx);
    }
    error(msg, ctx) {
        this.log('error', msg, ctx);
    }
    fatal(msg, ctx) {
        this.log('fatal', msg, ctx);
    }
}
exports.Logger = Logger;
class Mute extends Logger {
    log(level, msg, ctx) {
    }
}
exports.Mute = Mute;
class Contextual extends Logger {
    constructor(dst, ctx) {
        super();
        this.dst = dst;
        this.ctx = Object.assign({}, ctx);
    }
    log(level, msg, ctx) {
        const mergedCtx = Object.assign({}, this.ctx, ctx);
        this.emit('message', level, msg, mergedCtx);
        this.dst.log(level, msg, mergedCtx);
    }
    close() {
        this.dst.close();
        super.close();
    }
}
class SighupFileTransport extends winston.transports.File {
    constructor(options) {
        super(options);
        this.listener = this.sighup.bind(this);
        process.on("SIGHUP", this.listener);
    }
    sighup() {
        const self = this;
        const filename = path.join(self.dirname, self._getFile(false));
        fs.stat(filename, (err) => {
            if (err && err.code === "ENOENT") {
                self.reopenFile(filename);
            }
        });
    }
    reopenFile(filename) {
        const self = this;
        if (self._stream) {
            self._stream.end();
            self._stream.destroySoon();
        }
        const stream = fs.createWriteStream(filename, self.options);
        stream.setMaxListeners(Infinity);
        self._size = 0;
        self._stream = stream;
        self.once("flush", () => {
            self.opening = false;
            self.emit("open", filename);
        });
        self.flush();
    }
    close() {
        process.removeListener('SIGHUP', this.listener);
        super.close();
    }
}
class WinstonLogger extends Logger {
    constructor(level = "info") {
        super();
        this.impl = new winston.Logger({
            colors: colors,
            level: level,
            levels: exports.levels,
            transports: [],
        });
    }
    log(level, msg, ctx = {}) {
        let newMsg = msg;
        if (ctx.service) {
            newMsg = `[${ctx.service}] ${msg}`;
            delete ctx.service;
        }
        this.emit('message', level, newMsg, ctx);
        this.impl.log(level, newMsg, ctx);
    }
    close() {
        this.impl.close();
        this.impl.unhandleExceptions();
        super.close();
    }
    add(transportClass, params) {
        this.impl.add(transportClass, params);
    }
    addConsole() {
        this.add(winston.transports.Console, {
            json: (process.env.ROS_LOG_JSON === "1"),
            colorize: process.stdout.isTTY,
            timestamp: (process.env.ROS_LOG_TIMESTAMP === "1"),
            stderrLevels: levelNames,
        });
    }
    addFile(filename) {
        this.add(SighupFileTransport, {
            json: (process.env.ROS_LOG_JSON === "1"),
            filename: filename,
            timestamp: (process.env.ROS_LOG_TIMESTAMP === "1"),
            handleExceptions: true,
            humanReadableUnhandledException: true,
        });
    }
}
exports.WinstonLogger = WinstonLogger;
class Console extends WinstonLogger {
    constructor(level) {
        super(level);
        this.addConsole();
    }
}
exports.Console = Console;
class File extends WinstonLogger {
    constructor(filename, level) {
        super(level);
        this.addFile(filename);
    }
}
exports.File = File;
class FileConsole extends WinstonLogger {
    constructor(filename, level) {
        super(level);
        if (process.stdout.isTTY) {
            this.addConsole();
        }
        if (filename) {
            this.addFile(filename);
        }
    }
}
exports.FileConsole = FileConsole;
//# sourceMappingURL=Logger.js.map