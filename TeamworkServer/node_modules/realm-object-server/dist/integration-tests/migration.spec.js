"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const Realm = require("realm");
const TestServer_1 = require("../TestServer");
const Logger_1 = require("../shared/Logger");
const chai_1 = require("chai");
const chai = require("chai");
chai.use(require("chai-as-promised"));
const tmp = require("tmp");
const tar = require("tar");
const path = require("path");
const offers = {
    revoked: 'e31c424527b92227a9d54f943bb4ccbe:8c47a0e9-c26a-415c-88f7-8c08d44dd611',
    read: 'e31c424527b92227a9d54f943bb4ccbe:183cd29f-cf1c-45a5-bb0b-cc496ba2afd6',
    write: 'e31c424527b92227a9d54f943bb4ccbe:7bd6c49d-77c3-4036-b134-0729a45ff04d',
};
function uploadWithTimeout(realm, ms) {
    return __awaiter(this, void 0, void 0, function* () {
        return new Promise((resolve, reject) => {
            let timeout;
            const progress = (a, b) => {
                if (a === b) {
                    realm.syncSession.removeProgressNotification(progress);
                    clearTimeout(timeout);
                    resolve(true);
                }
            };
            realm.syncSession.addProgressNotification('upload', 'forCurrentlyOutstandingWork', progress);
            timeout = setTimeout(() => {
                try {
                    realm.syncSession.removeProgressNotification(progress);
                }
                catch (e) {
                }
                resolve(false);
            }, ms);
        });
    });
}
describe('Migration', function () {
    let server;
    let user;
    let oldros;
    let readurl;
    let writeurl;
    let newros;
    before(() => __awaiter(this, void 0, void 0, function* () {
        oldros = tmp.dirSync({ unsafeCleanup: true });
        newros = tmp.dirSync({ unsafeCleanup: true });
        yield tar.x({
            file: path.resolve(__dirname, "../../fixtures/old-ros-data.tar"),
            strip: 1,
            C: oldros.name,
        });
        server = new TestServer_1.TestServer();
        yield server["runMigration"]({
            from: path.join(oldros.name, "root_dir"),
            to: newros.name,
            copyrealms: true,
        }, new Logger_1.Mute());
        yield server.start({
            dataPath: newros.name,
            privateKeyPath: path.join(oldros.name, "keys", "token-signature.key"),
            publicKeyPath: path.join(oldros.name, "keys", "token-signature.pub"),
            autoKeyGen: false,
        });
        user = yield Realm.Sync.User.login(server.url, 'bob', 'b0b');
    }));
    after(() => __awaiter(this, void 0, void 0, function* () {
        yield server.shutdown();
        oldros.removeCallback();
        newros.removeCallback();
    }));
    describe("After migration, bob", () => {
        it("should not be able to accept the revoked offer", () => __awaiter(this, void 0, void 0, function* () {
            yield chai_1.assert.isRejected(user.acceptPermissionOffer(offers.revoked));
        }));
        it.skip("should be able accept the read offer", () => __awaiter(this, void 0, void 0, function* () {
            readurl = yield user.acceptPermissionOffer(offers.read);
        }));
        it.skip("shoule be able the write offer", () => __awaiter(this, void 0, void 0, function* () {
            writeurl = yield user.acceptPermissionOffer(offers.write);
        }));
        function canRead(name) {
            return __awaiter(this, void 0, void 0, function* () {
                let realm;
                try {
                    yield new Promise((resolve, reject) => {
                        realm = new Realm({
                            path: path.join(server.dataPath, `${name}.realm`),
                            sync: {
                                url: `realm://${server.address}/e31c424527b92227a9d54f943bb4ccbe/${name}`,
                                user,
                                error: (a, b) => {
                                    realm.close();
                                    realm = null;
                                    reject(b.message);
                                },
                            },
                            schema: [{ name: 'Item', properties: { id: 'int', name: 'string' } }],
                        });
                        realm.syncSession.addProgressNotification('download', 'forCurrentlyOutstandingWork', (a, b) => {
                            if (a === b) {
                                resolve();
                            }
                        });
                    });
                    return realm.objects('Item').length === 10;
                }
                catch (e) {
                    return false;
                }
                finally {
                    if (realm) {
                        realm.close();
                    }
                }
            });
        }
        function canWrite(name) {
            return __awaiter(this, void 0, void 0, function* () {
                let realm;
                try {
                    const can = yield new Promise((resolve, reject) => {
                        realm = new Realm({
                            path: path.join(server.dataPath, `${name}.realm`),
                            sync: {
                                url: `realm://${server.address}/e31c424527b92227a9d54f943bb4ccbe/${name}`,
                                user,
                                error: (a, b) => {
                                    realm.close();
                                    realm = null;
                                    reject(b.message);
                                },
                            },
                            schema: [{ name: 'Item', properties: { id: 'int', name: 'string' } }],
                        });
                        realm.write(() => {
                            realm.create('Item', { id: 10, name: 'world' });
                        });
                        uploadWithTimeout(realm, 1000).then(resolve);
                    });
                    return can;
                }
                catch (e) {
                    return false;
                }
                finally {
                    if (realm) {
                        realm.close();
                    }
                }
            });
        }
        describe("for realm 4bobr", () => {
            it("can read the realm", () => __awaiter(this, void 0, void 0, function* () {
                chai_1.assert.isTrue(yield canRead('4bobr'));
            }));
            it.skip("cannot write the realm", () => __awaiter(this, void 0, void 0, function* () {
                chai_1.assert.isFalse(yield canWrite('4bobr'));
            }));
        });
        describe("for realm 4anyr", () => {
            it.skip("can read the realm", () => __awaiter(this, void 0, void 0, function* () {
                chai_1.assert.isTrue(yield canRead('4anyr'));
            }));
            it("cannot write the realm", () => __awaiter(this, void 0, void 0, function* () {
                chai_1.assert.isFalse(yield canWrite('4anyr'));
            }));
        });
        describe("for realm 4bobrw", () => {
            it.skip("can write the realm", () => __awaiter(this, void 0, void 0, function* () {
                chai_1.assert.isTrue(yield canWrite('4bobrw'));
            }));
        });
        describe("for realm private", () => {
            it.skip("cannot read the realm", () => __awaiter(this, void 0, void 0, function* () {
                chai_1.assert.isFalse(yield canRead('private'));
            }));
        });
    });
});
//# sourceMappingURL=migration.spec.js.map