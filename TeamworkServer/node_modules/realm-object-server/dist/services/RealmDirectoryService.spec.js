"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const chai_1 = require("chai");
const superagent = require("superagent");
const Realm = require("realm");
const uuid = require("uuid");
const URI = require("urijs");
const TestServer_1 = require("../TestServer");
const services = require(".");
const auth = require("../auth");
const Token_1 = require("../shared/Token");
const Token_2 = require("../shared/Token");
const realms_1 = require("../realms");
describe('RealmDirectoryService Tests', function () {
    let server;
    let username = `Manny${uuid.v4()}`;
    let password = `bat${uuid.v4()}`;
    let userToken;
    let adminUsername = `Admin${uuid.v4()}`;
    let adminPassword = `admin${uuid.v4()}`;
    let adminUserToken;
    let authServiceHandle;
    let realmsServiceHandle;
    let tmpDir;
    let realmDirectoryService;
    let authService;
    let authServiceUrl;
    let realmsServiceUrl;
    let serverUrl;
    let passwordAuthProvider;
    beforeEach(function () {
        return __awaiter(this, void 0, void 0, function* () {
            server = new TestServer_1.TestServer();
            passwordAuthProvider = new auth.PasswordAuthProvider({ iterations: 1 });
            yield server.start({
                authProviders: [passwordAuthProvider],
            });
            authService = server.getService('auth');
            realmDirectoryService = server.getService('realms');
            serverUrl = `http://${server.address}`;
            authServiceHandle = yield server.discovery.find('auth');
            realmsServiceHandle = yield server.discovery.find('realms');
            authServiceUrl = new URI(`http://${authServiceHandle.address}:${authServiceHandle.port}`)
                .segment("/auth").toString();
            realmsServiceUrl = new URI(`http://${realmsServiceHandle.address}:${realmsServiceHandle.port}`)
                .segment("/realms").toString();
            realmDirectoryService = server.services.find(s => s instanceof services.RealmDirectoryService);
            let userResponse = yield superagent
                .post(authServiceUrl)
                .send({ provider: 'password', username: username, password: password, register: true });
            userToken = userResponse.body.refresh_token.token;
            let adminUserResponse = yield superagent
                .post(authServiceUrl)
                .send({ provider: 'password', username: adminUsername, password: adminPassword, register: true, is_admin: true });
            adminUserToken = adminUserResponse.body.refresh_token.token;
        });
    });
    afterEach(function () {
        return __awaiter(this, void 0, void 0, function* () {
            if (server) {
                yield server.shutdown();
            }
            Realm.clearTestState();
        });
    });
    it('registers realms when getting an access token', function () {
        return __awaiter(this, void 0, void 0, function* () {
            const user = yield authService.createOrUpdateUser(uuid.v4(), "debug", false);
            const userRefreshToken = new Token_2.RefreshToken({
                isAdmin: true,
                identity: user.userId,
                appId: 'io.realm.Auth',
            }).sign(server.privateKey);
            const realmAccessTokenResponse = yield superagent
                .post(authServiceUrl)
                .send({
                path: '/myrealm',
                data: userRefreshToken,
                provider: 'realm'
            });
            chai_1.expect(realmAccessTokenResponse.body.access_token.token).to.be.a('string');
            const adminRealm = yield server.realmFactory.open(realms_1.AdminRealm);
            chai_1.expect(adminRealm.objectForPrimaryKey('RealmFile', '/myrealm')).to.not.be.undefined;
            adminRealm.close();
        });
    });
    it('registers the internal realms used by ROS', function () {
        return __awaiter(this, void 0, void 0, function* () {
            const adminRealm = yield server.realmFactory.open(realms_1.AdminRealm);
            chai_1.expect(adminRealm.objectForPrimaryKey('RealmFile', '/__admin')).to.not.be.undefined;
            adminRealm.close();
        });
    });
    it('can properly ask for a realm with an Admin Token User access_token ', function () {
        return __awaiter(this, void 0, void 0, function* () {
            const privateKey = server.privateKey;
            const adminToken = yield Token_1.generateAdminToken(privateKey);
            const adminTokenUser = Realm.Sync.User.adminUser(adminToken, "some url");
            const url = new URI(realmsServiceUrl)
                .segment('files')
                .segment('%2Fproducts')
                .toString();
            const response = yield superagent
                .get(url)
                .set({
                'X-Realm-Access-Token': adminTokenUser.token
            });
            chai_1.expect(response.body.path).to.be.eq('/products');
            chai_1.expect(response.body.syncLabel).to.not.be.undefined;
            const adminRealm = yield server.realmFactory.open(realms_1.AdminRealm);
            chai_1.expect(adminRealm.objectForPrimaryKey('RealmFile', '/products')).to.not.be.undefined;
            adminRealm.close();
        });
    });
    it('it can ask for a realm path with ~ and be expanded with the userId', function () {
        return __awaiter(this, void 0, void 0, function* () {
            yield passwordAuthProvider["attemptToRegister"]('sally', 'ilovesushi', true);
            const user = yield Realm.Sync.User.login(serverUrl, 'sally', 'ilovesushi');
            const realm = yield Realm.open({
                sync: {
                    url: `realm://${server.address}/~/products`,
                    user: user
                }
            });
            const adminRealm = yield server.realmFactory.open(realms_1.AdminRealm);
            const foundRealmFile = adminRealm.objectForPrimaryKey('RealmFile', `/${user.identity}/products`);
            chai_1.expect(foundRealmFile).to.not.be.undefined;
            adminRealm.close();
        });
    });
});
//# sourceMappingURL=RealmDirectoryService.spec.js.map