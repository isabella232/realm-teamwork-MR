"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const decorators_1 = require("../decorators");
const Logger_1 = require("../shared/Logger");
const Token_1 = require("../shared/Token");
const Server_1 = require("../Server");
const errors = require("../errors");
const realms_1 = require("../realms");
const util_1 = require("../shared/util");
const URI = require("urijs");
const superagent = require("superagent");
let RealmDirectoryService = class RealmDirectoryService {
    constructor(config = {}) {
        this.logger = new Logger_1.Mute();
        this.config = config;
        if (!this.config.tags || this.config.tags.length === 0) {
            this.config.tags = ["master"];
        }
        this.tags = this.config.tags;
    }
    setLogger(l) {
        this.logger = l;
    }
    find() {
        return __awaiter(this, void 0, void 0, function* () {
            const realmFiles = this.adminRealm.objects("RealmFile").slice();
            return realmFiles;
        });
    }
    findByPath(realmPath, accessToken) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!accessToken) {
                throw new errors.JSONError({
                    title: "X-Realm-Access-Token header is not valid",
                    status: 400,
                });
            }
            const token = Token_1.Token.parse(accessToken, this.publicKey);
            realmPath = util_1.validateRealmPath(realmPath, token);
            let realmFile = this.adminRealm.objectForPrimaryKey("RealmFile", realmPath);
            if (!realmFile) {
                realmFile = (yield this.createRealmFile(realmPath, token.identity));
                const user = this.adminRealm.objectForPrimaryKey('User', token.identity);
                const isHomeDirectoryOwner = new URI(realmPath).segment()[0] === token.identity;
                const isUserAnAdminOrAdminTokenUser = token.identity === '__admin' || user.isAdmin === true;
                if (!isUserAnAdminOrAdminTokenUser && isHomeDirectoryOwner) {
                    this.adminRealm.write(() => {
                        this.adminRealm.create('Permission', {
                            realmFile: realmFile,
                            mayManage: true,
                            mayRead: true,
                            mayWrite: true,
                            updatedAt: new Date(),
                            user: user
                        });
                    });
                }
            }
            const user = this.adminRealm.objectForPrimaryKey('User', token.identity);
            const isHomeDirectoryOwner = new URI(realmPath).segment()[0] === token.identity;
            if (user && isHomeDirectoryOwner) {
                const userPermissions = realmFile.permissions.filtered("user.userId = $0", user.userId);
                const isUserAnAdminOrAdminTokenUser = token.identity === '__admin' || user.isAdmin === true;
                if (!isUserAnAdminOrAdminTokenUser && userPermissions.length === 0) {
                    this.adminRealm.write(() => {
                        realmFile.owner = user;
                        this.adminRealm.create('Permission', {
                            realmFile: realmFile,
                            mayManage: true,
                            mayRead: true,
                            mayWrite: true,
                            updatedAt: new Date(),
                            user: user
                        });
                    });
                }
            }
            return {
                path: realmFile.path,
                syncLabel: realmFile.syncLabel
            };
        });
    }
    remove(realmPath, req) {
        return __awaiter(this, void 0, void 0, function* () {
            realmPath = '/' + realmPath;
            const token = req.authToken;
            if (!token) {
                throw new errors.realm.AccessDenied();
            }
            const foundRevocation = this.tokenRevocationRealm.objectForPrimaryKey('TokenRevocation', token.encodedData());
            if (foundRevocation) {
                throw new errors.realm.AccessDenied();
            }
            let accessToDeleteRealm = token.isAdmin || token.identity === '__admin' || token.path === realmPath;
            if (!accessToDeleteRealm) {
                throw new errors.realm.AccessDenied();
            }
            const adminRealm = this.adminRealm;
            const realmFile = adminRealm.objectForPrimaryKey("RealmFile", realmPath);
            if (!realmFile) {
                throw new errors.realm.RealmNotFound;
            }
            const syncLabel = realmFile.syncLabel;
            const syncServerDeleteRealmUrl = yield this.getSyncServerDeleteRealmUrl(realmPath, syncLabel);
            adminRealm.write(() => {
                const realmFile = adminRealm.objectForPrimaryKey("RealmFile", realmPath);
                if (!realmFile) {
                    return;
                }
                adminRealm.delete(realmFile.permissions);
                adminRealm.delete(realmFile);
            });
            try {
                const response = yield superagent.delete(syncServerDeleteRealmUrl).set({
                    'Authorization': 'Realm-Access-Token version=1 token="' + this.adminToken + '"'
                });
            }
            catch (err) {
            }
            return {};
        });
    }
    getSyncServerDeleteRealmUrl(realmPath, syncLabel) {
        return __awaiter(this, void 0, void 0, function* () {
            const syncServerHandle = yield this.discovery.find('sync', ['master', syncLabel]);
            if (!syncServerHandle) {
                throw new Error("Unable to locate the sync server");
            }
            return new URI(`http://${syncServerHandle.address}:${syncServerHandle.port}`)
                .segment("/api/realm")
                .segment(realmPath)
                .toString();
        });
    }
    validatedRealmFile(path) {
        if (!path) {
            throw new errors.realm.MissingParameters('path');
        }
        let realmFile = this.adminRealm.objectForPrimaryKey('RealmFile', path);
        if (!realmFile) {
            throw new errors.JSONError({
                detail: `Realm path: ${path}`,
                title: 'The provided path does not exist',
                status: 403
            });
        }
        return realmFile;
    }
    start(server) {
        return __awaiter(this, void 0, void 0, function* () {
            this.discovery = server.discovery;
            this.publicKey = server.publicKey;
            this.adminToken = server.adminToken;
            this.adminRealm = yield server.realmFactory.open(realms_1.AdminRealm);
            this.tokenRevocationRealm = yield server.realmFactory.open(realms_1.TokenRevocationRealm);
            for (const definition of [realms_1.AdminRealm, realms_1.TokenRevocationRealm]) {
                const realmFile = this.adminRealm.objectForPrimaryKey('RealmFile', definition.remotePath);
                if (!realmFile) {
                    this.createRealmFile(definition.remotePath, '', definition.syncLabel);
                }
            }
        });
    }
    stop() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.tokenRevocationRealm) {
                this.tokenRevocationRealm.close();
                delete this.tokenRevocationRealm;
            }
            if (this.adminRealm) {
                this.adminRealm.close();
                delete this.adminRealm;
            }
        });
    }
    createRealmFile(path, creatorId, syncLabel) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!syncLabel) {
                const sync = yield this.discovery.find('sync', ["master"]);
                if (!sync) {
                    syncLabel = "default";
                }
                else {
                    syncLabel = sync.tags.filter((t) => {
                        return t !== "master" && t !== "slave";
                    })[0] || "default";
                }
            }
            let owner;
            if (creatorId) {
                owner = this.adminRealm.objectForPrimaryKey('User', creatorId);
            }
            let realmFile;
            this.adminRealm.write(() => {
                realmFile = this.adminRealm.create('RealmFile', {
                    owner: owner,
                    path: path,
                    createdAt: new Date(),
                    syncLabel: syncLabel,
                });
            });
            return realmFile;
        });
    }
};
__decorate([
    decorators_1.Unmute(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Logger_1.Logger]),
    __metadata("design:returntype", void 0)
], RealmDirectoryService.prototype, "setLogger", null);
__decorate([
    decorators_1.Get('/files'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], RealmDirectoryService.prototype, "find", null);
__decorate([
    decorators_1.Get('/files/:realmPath'),
    __param(0, decorators_1.Params('realmPath')),
    __param(1, decorators_1.Headers('X-Realm-Access-Token')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String]),
    __metadata("design:returntype", Promise)
], RealmDirectoryService.prototype, "findByPath", null);
__decorate([
    decorators_1.Delete('/files/:realmPath'),
    __param(0, decorators_1.Params('realmPath')),
    __param(1, decorators_1.Request()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object]),
    __metadata("design:returntype", Promise)
], RealmDirectoryService.prototype, "remove", null);
__decorate([
    decorators_1.Start(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Server_1.Server]),
    __metadata("design:returntype", Promise)
], RealmDirectoryService.prototype, "start", null);
__decorate([
    decorators_1.Stop(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], RealmDirectoryService.prototype, "stop", null);
RealmDirectoryService = __decorate([
    decorators_1.BaseRoute('/realms'),
    decorators_1.ServiceName('realms'),
    __metadata("design:paramtypes", [Object])
], RealmDirectoryService);
exports.RealmDirectoryService = RealmDirectoryService;
//# sourceMappingURL=RealmDirectoryService.js.map