"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const decorators_1 = require("../decorators");
const Server_1 = require("../Server");
const Token_1 = require("../shared/Token");
const realms_1 = require("../realms");
const errors = require("../errors");
const path = require("path");
const moment = require("moment");
const URI = require("urijs");
const _ = require("lodash");
const events_1 = require("events");
let PermissionService = PermissionService_1 = class PermissionService extends events_1.EventEmitter {
    start(server) {
        return __awaiter(this, void 0, void 0, function* () {
            this.server = server;
            this.dataPath = path.resolve(server.dataPath, "permissions");
            this.privateKey = server.privateKey;
            this.publicKey = server.publicKey;
            this.logger = server.logger;
            this.adminTokenUser = Realm.Sync.User.adminUser(Token_1.generateAdminToken(this.privateKey), `http://${server.address}`);
            this.adminRealm = yield server.realmFactory.open(realms_1.AdminRealm);
            this.wildcardPermissionRealm = yield server.realmFactory.open(realms_1.WildcardPermissionRealm);
        });
    }
    serverStarted(server) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.grantReadOnlyAccessToWildcardPermissionRealm();
            const syncBaseUrl = `realm://${server.address}`;
            const authUrl = `http://${server.address}`;
            this.handleAdminChangeCallback = this.handleAdminRealmPermissionToReflection.bind(this);
            Realm.Sync.addListener(syncBaseUrl, Realm.Sync.User.adminUser(Token_1.generateAdminToken(this.privateKey), authUrl), PermissionService_1.ADMIN_REALM_REGEX, 'change', this.handleAdminChangeCallback);
            this.handleManagementChangeCallback = this.handleManagementRealmChange.bind(this);
            Realm.Sync.addListener(syncBaseUrl, Realm.Sync.User.adminUser(Token_1.generateAdminToken(this.privateKey), authUrl), PermissionService_1.MANAGEMENT_REALM_REGEX, 'change', this.handleManagementChangeCallback);
        });
    }
    stop() {
        if (this.handleManagementChangeCallback) {
            Realm.Sync.removeListener(PermissionService_1.MANAGEMENT_REALM_REGEX, 'change', this.handleManagementChangeCallback);
            delete this.handleManagementChangeCallback;
        }
        if (this.handleAdminChangeCallback) {
            Realm.Sync.removeListener(PermissionService_1.ADMIN_REALM_REGEX, 'change', this.handleAdminChangeCallback);
            delete this.handleAdminChangeCallback;
        }
        if (this.adminRealm) {
            this.adminRealm.close();
            delete this.adminRealm;
        }
        if (this.wildcardPermissionRealm) {
            this.wildcardPermissionRealm.close();
            delete this.wildcardPermissionRealm;
        }
    }
    onDemand(accessToken) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!accessToken) {
                throw new errors.JSONError({
                    title: "X-Realm-Access-Token header is not valid",
                    status: 400,
                });
            }
            const token = Token_1.Token.parse(accessToken, this.publicKey);
            const userId = token.identity;
            const permissionsInAdminRealm = this.adminRealm.objects('Permission')
                .filtered('user.userId = $0 || realmFile.owner.userId = $0', userId);
            const userSpecificRealm = yield this.getUserSpecificPermissionRealm(userId);
            try {
                let didUpdateAnyPermission = false;
                userSpecificRealm.beginTransaction();
                for (const permissionFromAdminRealm of permissionsInAdminRealm.snapshot().filter(p => p.user)) {
                    didUpdateAnyPermission = this.updateOrCreateUserPermissionWithAdminPermission(userSpecificRealm, permissionFromAdminRealm);
                }
                if (didUpdateAnyPermission) {
                    userSpecificRealm.commitTransaction();
                }
                else {
                    userSpecificRealm.cancelTransaction();
                }
                return {
                    userId: userId,
                    affectedPermissionsCount: permissionsInAdminRealm.length
                };
            }
            finally {
                userSpecificRealm.close();
            }
        });
    }
    updateOrCreateUserPermissionWithAdminPermission(userSpecificRealm, adminPermission) {
        const userSpecificPermission = userSpecificRealm.objects("Permission")
            .filtered('userId = $0 && path = $1', adminPermission.user.userId, adminPermission.realmFile.path)[0];
        if (!userSpecificPermission) {
            userSpecificRealm.create(realms_1.UserSpecificPermission.schema.name, {
                path: adminPermission.realmFile.path,
                userId: adminPermission.user ? adminPermission.user.userId : '*',
                mayRead: adminPermission.mayRead,
                mayWrite: adminPermission.mayWrite,
                mayManage: adminPermission.mayManage,
                updatedAt: new Date()
            });
            return true;
        }
        let updatePermission = (userSpecificPermission.mayRead !== adminPermission.mayRead) ||
            (userSpecificPermission.mayWrite !== adminPermission.mayWrite) ||
            (userSpecificPermission.mayManage !== adminPermission.mayManage);
        if (updatePermission) {
            userSpecificPermission.mayRead = adminPermission.mayRead;
            userSpecificPermission.mayWrite = adminPermission.mayWrite;
            userSpecificPermission.mayManage = adminPermission.mayManage;
            userSpecificPermission.updatedAt = new Date();
            return true;
        }
        return false;
    }
    getUserByUserId(userId) {
        return this.adminRealm.objectForPrimaryKey('User', userId);
    }
    getUserByProviderId(providerId, provider) {
        const accounts = this.adminRealm.objects('Account').filtered(`provider = $0 AND providerId = $1`, provider, providerId);
        if (accounts.length > 0) {
            return accounts[0].user[0];
        }
    }
    getUserIdsWithMetadata(key, value) {
        let userIds = new Set();
        if (key === 'email') {
            const user = this.getUserByProviderId(value, 'password');
            if (user) {
                userIds.add(user.userId);
            }
        }
        let metadata = this.adminRealm.objects('UserMetadataRow');
        if (key && value) {
            metadata = metadata.filtered("key = $0 AND value = $1", key, value);
        }
        metadata.forEach(meta => userIds.add(meta.user[0].userId));
        return Array.from(userIds);
    }
    getUsersByUserIds(userIds) {
        const query = userIds.map((id, index) => {
            return `userId = $${index}`;
        }).join(" || ");
        return this.adminRealm.objects("User").filtered(query, ...userIds);
    }
    getManagementRealmForUserId(userId) {
        return __awaiter(this, void 0, void 0, function* () {
            const realmDefinition = realms_1.CreateUserManagementRealmDefinition(userId);
            return this.server.realmFactory.open(realmDefinition);
        });
    }
    grantReadOnlyAccessToWildcardPermissionRealm() {
        return __awaiter(this, void 0, void 0, function* () {
            const wildcardRealmFile = this.adminRealm.objectForPrimaryKey('RealmFile', '/__wildcardpermissions');
            if (!wildcardRealmFile) {
                this.logger.error('Could not find the WildcardPermission RealmFile in Admin Realm!');
            }
            else {
                let wildcardPerm = wildcardRealmFile.permissions.filtered('user.userId == null')[0];
                if (!wildcardPerm) {
                    this.adminRealm.write(() => {
                        wildcardPerm = this.adminRealm.create('Permission', {
                            user: null,
                            realmFile: wildcardRealmFile,
                            updatedAt: new Date(),
                            mayRead: true,
                            mayWrite: false,
                            mayManage: false
                        });
                    });
                }
            }
        });
    }
    applyPermissionChangeInAdminRealm(realmFilePath, userId, mayRead, mayWrite, mayManage) {
        return __awaiter(this, void 0, void 0, function* () {
            const realmFile = this.adminRealm.objectForPrimaryKey("RealmFile", realmFilePath);
            if (!realmFile) {
                throw new errors.realm.InvalidParameters({ name: 'realmFilePath', reason: `The provided realmFilePath (${realmFilePath}) does not exist.` });
            }
            let permission;
            let user;
            let shouldDelete = (mayRead === false && mayWrite === false && mayManage === false);
            this.adminRealm.write(() => {
                if (userId) {
                    user = this.getUserByUserId(userId);
                    permission = realmFile.permissions.filtered('user.userId = $0', userId)[0];
                }
                else {
                    permission = realmFile.permissions.filtered('user == null')[0];
                }
                if (!permission && !shouldDelete) {
                    permission = this.adminRealm.create('Permission', {
                        user: user,
                        realmFile: realmFile,
                        updatedAt: new Date(),
                        mayRead: mayRead || false,
                        mayWrite: mayWrite || false,
                        mayManage: mayManage || false
                    });
                }
                else if (permission && shouldDelete) {
                    this.adminRealm.delete(permission);
                }
                else if (permission && !shouldDelete) {
                    if (mayRead != null) {
                        permission.mayRead = mayRead;
                    }
                    if (mayWrite != null) {
                        permission.mayWrite = mayWrite;
                    }
                    if (mayManage != null) {
                        permission.mayManage = mayManage;
                    }
                    permission.updatedAt = new Date();
                }
            });
        });
    }
    getUserSpecificPermissionRealm(userId) {
        const realmDefinition = realms_1.CreateUserPermissionRealmDefinition(userId);
        return this.server.realmFactory.open(realmDefinition);
    }
    getWildcardPermissionAndAssociatedRealm(realmPath) {
        return __awaiter(this, void 0, void 0, function* () {
            const wildcardPermission = this.wildcardPermissionRealm.objects("Permission").filtered('path = $0', realmPath)[0];
            return {
                wildcardPermissionRealm: this.wildcardPermissionRealm,
                wildcardPermission: wildcardPermission
            };
        });
    }
    getUserSpecificPermissionAndAssociatedRealm(realmPath, userId) {
        return __awaiter(this, void 0, void 0, function* () {
            const realmDefinition = realms_1.CreateUserPermissionRealmDefinition(userId);
            const realm = yield this.server.realmFactory.open(realmDefinition);
            const userSpecificPermission = realm.objects("Permission").filtered('path = $0 AND userId = $1', realmPath, userId)[0];
            return {
                userSpecificRealm: realm,
                userSpecificPermission: userSpecificPermission
            };
        });
    }
    getGrantorSpecificPermissionAndAssociatedRealm(realmPath, userId, granteeId) {
        return __awaiter(this, void 0, void 0, function* () {
            const realmDefinition = realms_1.CreateUserPermissionRealmDefinition(userId);
            const realm = yield this.server.realmFactory.open(realmDefinition);
            const userSpecificPermission = realm.objects("Permission").filtered('path = $0 AND userId = $1', realmPath, granteeId)[0];
            return {
                grantorSpecificRealm: realm,
                grantorSpecificPermission: userSpecificPermission
            };
        });
    }
    createOrUpdateWildcardPermissionRealmFromReflection(wildcardPermissionRealm, permissionToReflect, permissionToUpdate) {
        wildcardPermissionRealm.write(() => {
            if (!permissionToUpdate) {
                const perm = wildcardPermissionRealm.create('Permission', {
                    mayRead: permissionToReflect.mayRead,
                    mayWrite: permissionToReflect.mayWrite,
                    mayManage: permissionToReflect.mayManage,
                    path: permissionToReflect.realmFile.path,
                    updatedAt: new Date()
                });
            }
            else {
                permissionToUpdate.mayRead = permissionToReflect.mayRead;
                permissionToUpdate.mayWrite = permissionToReflect.mayWrite;
                permissionToUpdate.mayManage = permissionToReflect.mayManage;
                permissionToUpdate.path = permissionToReflect.realmFile.path;
                permissionToUpdate.updatedAt = new Date();
            }
        });
    }
    createOrUpdateUserSpecificRealmFromReflection(userSpecificRealm, permissionToReflect, permissionToUpdate) {
        userSpecificRealm.write(() => {
            if (!permissionToUpdate) {
                userSpecificRealm.create('Permission', {
                    mayRead: permissionToReflect.mayRead,
                    mayWrite: permissionToReflect.mayWrite,
                    mayManage: permissionToReflect.mayManage,
                    path: permissionToReflect.realmFile.path,
                    userId: permissionToReflect.user.userId,
                    updatedAt: new Date()
                });
            }
            else {
                permissionToUpdate.mayRead = permissionToReflect.mayRead;
                permissionToUpdate.mayWrite = permissionToReflect.mayWrite;
                permissionToUpdate.mayManage = permissionToReflect.mayManage;
                permissionToUpdate.path = permissionToReflect.realmFile.path;
                permissionToUpdate.updatedAt = new Date();
                permissionToUpdate.userId = permissionToReflect.user.userId;
            }
        });
    }
    handleAdminRealmPermissionToReflection(changeEvent) {
        return __awaiter(this, void 0, void 0, function* () {
            const permissionChanges = changeEvent.changes['Permission'];
            if (permissionChanges) {
                const collection = changeEvent.realm.objects('Permission');
                let deletedPermissions = [];
                if (permissionChanges.deletions.length > 0) {
                    const oldCollection = changeEvent.oldRealm.objects('Permission');
                    deletedPermissions = permissionChanges.deletions.map((i) => {
                        const permission = oldCollection[i];
                        return { path: permission.realmFile.path, granteeId: permission.user.userId, grantorId: permission.realmFile.owner.userId };
                    });
                }
                this.emit('handlePermissionReflection', changeEvent);
                const insertedPermissions = permissionChanges.insertions.map(i => collection[i]);
                const modifiedPermissions = permissionChanges.modifications.map(i => collection[i]);
                const insertedAndChangedPermission = insertedPermissions.concat(modifiedPermissions);
                for (let permission of insertedAndChangedPermission) {
                    if (!permission.user) {
                        const { wildcardPermission } = yield this.getWildcardPermissionAndAssociatedRealm(permission.realmFile.path);
                        this.createOrUpdateWildcardPermissionRealmFromReflection(this.wildcardPermissionRealm, permission, wildcardPermission);
                    }
                    else {
                        const { userSpecificRealm, userSpecificPermission } = yield this.getUserSpecificPermissionAndAssociatedRealm(permission.realmFile.path, permission.user.userId);
                        this.createOrUpdateUserSpecificRealmFromReflection(userSpecificRealm, permission, userSpecificPermission);
                        userSpecificRealm.close();
                        const { grantorSpecificRealm, grantorSpecificPermission } = yield this.getGrantorSpecificPermissionAndAssociatedRealm(permission.realmFile.path, permission.realmFile.owner.userId, permission.user.userId);
                        this.createOrUpdateUserSpecificRealmFromReflection(grantorSpecificRealm, permission, grantorSpecificPermission);
                        grantorSpecificRealm.close();
                    }
                }
                for (const p of deletedPermissions) {
                    const { userSpecificPermission, userSpecificRealm } = yield this.getUserSpecificPermissionAndAssociatedRealm(p.path, p.granteeId);
                    if (!userSpecificPermission) {
                    }
                    else {
                        userSpecificRealm.write(() => {
                            userSpecificRealm.delete(userSpecificPermission);
                        });
                    }
                    userSpecificRealm.close();
                    const { grantorSpecificPermission, grantorSpecificRealm } = yield this.getGrantorSpecificPermissionAndAssociatedRealm(p.path, p.grantorId, p.granteeId);
                    if (!grantorSpecificPermission) {
                    }
                    else {
                        grantorSpecificRealm.write(() => {
                            grantorSpecificRealm.delete(grantorSpecificPermission);
                        });
                    }
                    grantorSpecificRealm.close();
                }
            }
        });
    }
    handleManagementRealmChange(changeEvent) {
        return __awaiter(this, void 0, void 0, function* () {
            const matches = changeEvent.path.match(PermissionService_1.MANAGEMENT_REALM_REGEX);
            if (!matches) {
                return;
            }
            ;
            const userId = matches[1];
            const realm = changeEvent.realm;
            this.logger.debug(`A management realm with path ${changeEvent.path} has changes with userId: ${userId}`);
            if (realm.schema.findIndex(objSchema => { return objSchema.name === 'PermissionOffer'; }) !== -1) {
                let unprocessedPermissionOfferObjects = realm.objects("PermissionOffer").filtered('statusCode == null');
                for (let p of unprocessedPermissionOfferObjects.snapshot()) {
                    this.handlePermissionOfferObject(p, userId, realm);
                }
            }
            if (realm.schema.findIndex(objSchema => { return objSchema.name === 'PermissionOfferResponse'; }) !== -1) {
                let unprocessedPermissionOfferResponseObjects = realm.objects("PermissionOfferResponse").filtered('statusCode == null');
                for (let p of unprocessedPermissionOfferResponseObjects.snapshot()) {
                    yield this.handlePermissionOfferResponseObject(p, userId, realm);
                }
            }
            if (realm.schema.findIndex(objSchema => { return objSchema.name === 'PermissionChange'; }) !== -1) {
                let unprocessedPermissionChangeObjects = realm.objects("PermissionChange").filtered('statusCode == null');
                for (let p of unprocessedPermissionChangeObjects.snapshot()) {
                    this.handlePermissionChangeObject(p, userId, realm);
                }
            }
        });
    }
    handlePermissionOfferObject(permissionOffer, ownerId, realm) {
        try {
            const realmPath = new URI(permissionOffer.realmUrl).path().replace('~', ownerId);
            this.validateUserIdCanChangePermissionsForPath(ownerId, realmPath);
            if (permissionOffer.expiresAt && moment(permissionOffer.expiresAt).isBefore(moment.now())) {
                throw new errors.realm.ExpiredPermissionOffer();
            }
            realm.write(() => {
                permissionOffer.realmUrl = realmPath;
                permissionOffer.token = `${ownerId}:${permissionOffer.id}`;
                permissionOffer.statusCode = 0;
            });
        }
        catch (err) {
            const problem = err;
            this.logger.error(problem.toString());
            realm.write(() => {
                permissionOffer.statusMessage = problem.title;
                permissionOffer.statusCode = problem.code;
            });
        }
    }
    handlePermissionOfferResponseObject(permissionOfferResponse, userId, realm) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const tokenComponents = permissionOfferResponse.token.split(':');
                if (tokenComponents.length < 2 || tokenComponents[0].length === 0) {
                    throw new errors.realm.InvalidParameters('token');
                }
                const offeringUserId = tokenComponents[0];
                let offeringRealm = yield this.getManagementRealmForUserId(offeringUserId);
                try {
                    const permissionOffers = offeringRealm.objects("PermissionOffer").filtered('token = $0', permissionOfferResponse.token);
                    if (permissionOffers.length === 0) {
                        throw new errors.realm.InvalidParameters('token');
                    }
                    if (permissionOffers.length > 1) {
                        throw new errors.realm.AmbiguousPermissionOfferToken({
                            detail: `Unexpected count of permission offers (=${permissionOffers.length})`
                                + ` matching the token '${permissionOfferResponse.token}' of the permission request!`,
                        });
                    }
                    const permissionOffer = permissionOffers[0];
                    if (permissionOffer.expiresAt && moment(permissionOffer.expiresAt).isBefore(moment.now())) {
                        throw new errors.realm.ExpiredPermissionOffer();
                    }
                    const realmPath = new URI(permissionOffer.realmUrl).path();
                    let mayRead = permissionOffer.mayRead || null;
                    let mayWrite = permissionOffer.mayWrite || null;
                    let mayManage = permissionOffer.mayManage || null;
                    this.applyPermissionChangeInAdminRealm(realmPath, userId, mayRead, mayWrite, mayManage);
                    realm.write(() => {
                        permissionOfferResponse.realmUrl = realmPath;
                        permissionOfferResponse.statusCode = 0;
                    });
                }
                finally {
                    offeringRealm.close();
                }
            }
            catch (err) {
                const problem = err;
                this.logger.error(problem.toString());
                realm.write(() => {
                    permissionOfferResponse.statusMessage = problem.title;
                    permissionOfferResponse.statusCode = problem.code;
                });
            }
        });
    }
    handlePermissionChangeObject(permissionChange, ownerId, realm) {
        try {
            const realmPath = new URI(permissionChange.realmUrl).path().replace('~', ownerId);
            if (permissionChange.userId === '*' && permissionChange.realmUrl === '*') {
                this.handleWildcardRealmUrlForAllUsers(permissionChange, ownerId);
            }
            else if (permissionChange.realmUrl === '*') {
                this.handleWildcardRealmUrlForUser(permissionChange, ownerId);
            }
            else if (permissionChange.userId === '*') {
                this.validateUserIdCanChangePermissionsForPath(ownerId, realmPath);
                this.handleWildcardUserIdUrl(permissionChange, realmPath);
            }
            else {
                this.validateUserIdCanChangePermissionsForPath(ownerId, realmPath);
                let users;
                if (permissionChange.metadataKey) {
                    const userIds = this.getUserIdsWithMetadata(permissionChange.metadataKey, permissionChange.metadataValue);
                    if (userIds.length === 0) {
                        throw new errors.realm.InvalidParameters({ name: 'metadataValue', reason: `The provided metadata value (${permissionChange.metadataValue}) matched no users.` });
                    }
                    this.logger.debug(`Apply permission change by metadata query 
                        (${permissionChange.metadataKey}=${permissionChange.metadataValue}) 
                        matching the userIds ${userIds}`);
                    users = this.getUsersByUserIds(userIds);
                }
                else {
                    this.logger.debug(`Apply permission change for user ${permissionChange.userId}`);
                    users = this.getUsersByUserIds([permissionChange.userId]);
                }
                const realmFiles = this.adminRealm.objects(realms_1.RealmFile.schema.name).filtered('path = $0', realmPath);
                this.setPermissionChangesInAdminRealm(users, realmFiles, permissionChange.mayWrite, permissionChange.mayRead, permissionChange.mayManage);
            }
            realm.write(() => {
                permissionChange.statusCode = 0;
                permissionChange.statusMessage = `Successfully applied PermissionChange for ${realmPath}`;
            });
        }
        catch (err) {
            const problem = err;
            this.logger.error(problem.toString());
            realm.write(() => {
                permissionChange.statusMessage = problem.title;
                permissionChange.statusCode = problem.code;
            });
        }
    }
    validateUserIdCanChangePermissionsForPath(userId, path) {
        if (_.includes(path, '__management')) {
            throw new errors.realm.InvalidParameters({
                name: 'realmUrl',
                reason: 'The realmUrl cannot be of a management realm'
            });
        }
        if (_.includes(path, '__permission')) {
            throw new errors.realm.InvalidParameters({
                name: 'realmUrl',
                reason: 'The realmUrl cannot be of a permission realm'
            });
        }
        const user = this.getUserByUserId(userId);
        const realmFile = this.adminRealm.objectForPrimaryKey(realms_1.RealmFile.schema.name, path);
        if (!realmFile) {
            throw new errors.realm.InvalidParameters({
                name: 'realmUrl',
                reason: 'The realmUrl does not exist'
            });
        }
        const permissions = realmFile.permissions.filtered('(user.userId = $0 OR user == null) AND mayManage = true', userId);
        if (!user.isAdmin && permissions.length === 0) {
            throw new errors.realm.AccessDenied();
        }
    }
    handleWildcardUserIdUrl(permissionChange, path) {
        this.applyPermissionChangeInAdminRealm(path, null, permissionChange.mayRead, permissionChange.mayWrite, permissionChange.mayManage);
    }
    handleWildcardRealmUrlForUser(permissionChange, ownerId) {
        const ownedRealmFiles = this.adminRealm.objects(realms_1.RealmFile.schema.name)
            .filtered('owner.userId = $0', ownerId);
        const users = this.getUsersByUserIds([permissionChange.userId]);
        this.setPermissionChangesInAdminRealm(users, ownedRealmFiles, permissionChange.mayWrite, permissionChange.mayRead, permissionChange.mayManage);
    }
    handleWildcardRealmUrlForAllUsers(permissionChange, ownerId) {
        const ownedRealmFiles = this.adminRealm.objects(realms_1.RealmFile.schema.name)
            .filtered('owner.userId = $0', ownerId);
        for (const realmFile of ownedRealmFiles) {
            this.applyPermissionChangeInAdminRealm(realmFile.path, null, permissionChange.mayRead, permissionChange.mayWrite, permissionChange.mayManage);
        }
    }
    setPermissionChangesInAdminRealm(users, realmFiles, mayWrite, mayRead, mayManage, permissionChange) {
        for (let file of realmFiles) {
            for (let user of users) {
                this.applyPermissionChangeInAdminRealm(file.path, user.userId, mayRead, mayWrite, mayManage);
            }
        }
    }
};
PermissionService.MANAGEMENT_REALM_REGEX = '^/([^/]+)/__management$';
PermissionService.ADMIN_REALM_REGEX = `/__admin`;
__decorate([
    decorators_1.Start(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Server_1.Server]),
    __metadata("design:returntype", Promise)
], PermissionService.prototype, "start", null);
__decorate([
    decorators_1.ServerStarted(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Server_1.Server]),
    __metadata("design:returntype", Promise)
], PermissionService.prototype, "serverStarted", null);
__decorate([
    decorators_1.Stop(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], PermissionService.prototype, "stop", null);
__decorate([
    decorators_1.Get('/ondemand'),
    __param(0, decorators_1.Headers('X-Realm-Access-Token')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], PermissionService.prototype, "onDemand", null);
PermissionService = PermissionService_1 = __decorate([
    decorators_1.BaseRoute('/permissions'),
    decorators_1.ServiceName('permissions')
], PermissionService);
exports.PermissionService = PermissionService;
var PermissionService_1;
//# sourceMappingURL=PermissionsService.js.map